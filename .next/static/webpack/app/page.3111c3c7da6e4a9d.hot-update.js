"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/time.ts":
/*!*********************!*\
  !*** ./lib/time.ts ***!
  \*********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BRAZIL_TZ: function() { return /* binding */ BRAZIL_TZ; },\n/* harmony export */   brazilTime: function() { return /* binding */ brazilTime; },\n/* harmony export */   calculateDuration: function() { return /* binding */ calculateDuration; },\n/* harmony export */   formatAgo: function() { return /* binding */ formatAgo; },\n/* harmony export */   formatDateOnly: function() { return /* binding */ formatDateOnly; },\n/* harmony export */   formatDateTime: function() { return /* binding */ formatDateTime; },\n/* harmony export */   formatTimeOnly: function() { return /* binding */ formatTimeOnly; },\n/* harmony export */   isToday: function() { return /* binding */ isToday; },\n/* harmony export */   parseClashTime: function() { return /* binding */ parseClashTime; },\n/* harmony export */   sortByDate: function() { return /* binding */ sortByDate; },\n/* harmony export */   toZoned: function() { return /* binding */ toZoned; }\n/* harmony export */ });\n// lib/time.ts\nconst BRAZIL_TZ = \"America/Sao_Paulo\";\n// Converte \"20250826T032310.000Z\" -> \"2025-08-26T03:23:10.000Z\" e cria Date\nfunction parseClashTime(input) {\n    if (!input || typeof input !== \"string\") return null;\n    // Já é ISO?\n    if (/^\\d{4}-\\d{2}-\\d{2}T/.test(input)) {\n        const d = new Date(input);\n        return isNaN(d.getTime()) ? null : d;\n    }\n    // Formato Clash: YYYYMMDDTHHMMSS(.mmm)?Z\n    const m = input.match(/^(\\d{4})(\\d{2})(\\d{2})T(\\d{2})(\\d{2})(\\d{2})(\\.\\d+)?Z$/);\n    if (!m) return null;\n    const [, Y, Mo, D, H, Mi, S, Ms = \".000\"] = m;\n    const iso = \"\".concat(Y, \"-\").concat(Mo, \"-\").concat(D, \"T\").concat(H, \":\").concat(Mi, \":\").concat(S).concat(Ms, \"Z\");\n    const d = new Date(iso);\n    return isNaN(d.getTime()) ? null : d;\n}\nfunction toZoned(date) {\n    let tz = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : BRAZIL_TZ;\n    // Cria \"equivalente\" no fuso\n    const inv = new Date(date.toLocaleString(\"en-US\", {\n        timeZone: tz\n    }));\n    const diff = date.getTime() - inv.getTime();\n    return new Date(date.getTime() - diff);\n}\nfunction formatDateTime(dateLike, opts) {\n    let tz = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : BRAZIL_TZ;\n    if (!dateLike) return \"--\";\n    const d = typeof dateLike === \"string\" ? parseClashTime(dateLike) : new Date(dateLike);\n    if (!d || isNaN(d.getTime())) return \"--\";\n    const z = toZoned(d, tz);\n    // Check if opts contains individual date/time components\n    const hasIndividualComponents = opts && (\"year\" in opts || \"month\" in opts || \"day\" in opts || \"hour\" in opts || \"minute\" in opts || \"second\" in opts || \"weekday\" in opts || \"era\" in opts || \"timeZoneName\" in opts);\n    // Check if opts contains any valid formatting options\n    const hasValidOptions = opts && (hasIndividualComponents || \"dateStyle\" in opts || \"timeStyle\" in opts || \"localeMatcher\" in opts || \"formatMatcher\" in opts);\n    const formatOptions = {\n        timeZone: tz,\n        ...opts\n    };\n    // Only add dateStyle/timeStyle if no individual components are specified and no valid options exist\n    if (!hasIndividualComponents && !hasValidOptions) {\n        formatOptions.dateStyle = \"short\";\n        formatOptions.timeStyle = \"short\";\n    }\n    return new Intl.DateTimeFormat(\"pt-BR\", formatOptions).format(z);\n}\nfunction formatDateOnly(dateLike) {\n    let tz = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : BRAZIL_TZ;\n    return formatDateTime(dateLike, {\n        dateStyle: \"medium\",\n        timeStyle: undefined\n    }, tz);\n}\nfunction formatTimeOnly(dateLike) {\n    let tz = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : BRAZIL_TZ;\n    return formatDateTime(dateLike, {\n        dateStyle: undefined,\n        timeStyle: \"short\"\n    }, tz);\n}\n// Função extra para mostrar \"há X tempo\"\nfunction formatAgo(dateLike) {\n    const d = typeof dateLike === \"string\" ? parseClashTime(dateLike) : new Date(dateLike);\n    if (!d || isNaN(d.getTime())) return \"--\";\n    const diff = Date.now() - d.getTime();\n    const mins = Math.floor(diff / 60000);\n    if (mins < 1) return \"agora\";\n    if (mins < 60) return \"h\\xe1 \".concat(mins, \" min\");\n    const hrs = Math.floor(mins / 60);\n    if (hrs < 24) return \"h\\xe1 \".concat(hrs, \" h\");\n    const days = Math.floor(hrs / 24);\n    return \"h\\xe1 \".concat(days, \" d\");\n}\n// Função para calcular duração entre duas datas\nfunction calculateDuration(startDate, endDate) {\n    const start = typeof startDate === \"string\" ? parseClashTime(startDate) : new Date(startDate);\n    const end = typeof endDate === \"string\" ? parseClashTime(endDate) : new Date(endDate);\n    if (!start || !end || isNaN(start.getTime()) || isNaN(end.getTime())) return \"--\";\n    const diff = end.getTime() - start.getTime();\n    const days = Math.floor(diff / (1000 * 60 * 60 * 24));\n    const hours = Math.floor(diff % (1000 * 60 * 60 * 24) / (1000 * 60 * 60));\n    const minutes = Math.floor(diff % (1000 * 60 * 60) / (1000 * 60));\n    if (days > 0) return \"\".concat(days, \"d \").concat(hours, \"h\");\n    if (hours > 0) return \"\".concat(hours, \"h \").concat(minutes, \"m\");\n    return \"\".concat(minutes, \"m\");\n}\n// Função para verificar se uma data é de hoje\nfunction isToday(dateLike) {\n    let tz = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : BRAZIL_TZ;\n    const d = typeof dateLike === \"string\" ? parseClashTime(dateLike) : new Date(dateLike);\n    if (!d || isNaN(d.getTime())) return false;\n    const today = new Date();\n    const target = toZoned(d, tz);\n    return today.getFullYear() === target.getFullYear() && today.getMonth() === target.getMonth() && today.getDate() === target.getDate();\n}\n// Função para ordenar array por data (mais recente primeiro)\nfunction sortByDate(items) {\n    let dateField = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"battleTime\", ascending = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    return items.map((item)=>({\n            ...item,\n            _parsedDate: parseClashTime(item[dateField])\n        })).filter((item)=>item._parsedDate).sort((a, b)=>{\n        const dateA = a._parsedDate.getTime();\n        const dateB = b._parsedDate.getTime();\n        return ascending ? dateA - dateB : dateB - dateA;\n    }).map((param)=>{\n        let { _parsedDate, ...item } = param;\n        return item;\n    });\n}\n/** Alias compatível com o que seu código esperava */ function brazilTime() {\n    return toZoned(new Date(), BRAZIL_TZ);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNwQyxPQUFPd0QsWUFBWVEsUUFBUUMsUUFBUUEsUUFBUUQ7SUFDN0MsR0FDQ1AsR0FBRyxDQUFDO1lBQUMsRUFBRUUsV0FBVyxFQUFFLEdBQUdELE1BQU07ZUFBS0E7O0FBQ3ZDO0FBRUEsbURBQW1ELEdBQzVDLFNBQVNRO0lBQ2QsT0FBT3ZELFFBQVEsSUFBSWIsUUFBUUw7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3RpbWUudHM/NjhlOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBsaWIvdGltZS50c1xuZXhwb3J0IGNvbnN0IEJSQVpJTF9UWiA9ICdBbWVyaWNhL1Nhb19QYXVsbyc7XG5cbi8vIENvbnZlcnRlIFwiMjAyNTA4MjZUMDMyMzEwLjAwMFpcIiAtPiBcIjIwMjUtMDgtMjZUMDM6MjM6MTAuMDAwWlwiIGUgY3JpYSBEYXRlXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDbGFzaFRpbWUoaW5wdXQ/OiBzdHJpbmcgfCBudWxsKTogRGF0ZSB8IG51bGwge1xuICBpZiAoIWlucHV0IHx8IHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHJldHVybiBudWxsO1xuICBcbiAgLy8gSsOhIMOpIElTTz9cbiAgaWYgKC9eXFxkezR9LVxcZHsyfS1cXGR7Mn1ULy50ZXN0KGlucHV0KSkge1xuICAgIGNvbnN0IGQgPSBuZXcgRGF0ZShpbnB1dCk7XG4gICAgcmV0dXJuIGlzTmFOKGQuZ2V0VGltZSgpKSA/IG51bGwgOiBkO1xuICB9XG4gIFxuICAvLyBGb3JtYXRvIENsYXNoOiBZWVlZTU1ERFRISE1NU1MoLm1tbSk/WlxuICBjb25zdCBtID0gaW5wdXQubWF0Y2goXG4gICAgL14oXFxkezR9KShcXGR7Mn0pKFxcZHsyfSlUKFxcZHsyfSkoXFxkezJ9KShcXGR7Mn0pKFxcLlxcZCspP1okL1xuICApO1xuICBpZiAoIW0pIHJldHVybiBudWxsO1xuICBcbiAgY29uc3QgWywgWSwgTW8sIEQsIEgsIE1pLCBTLCBNcyA9ICcuMDAwJ10gPSBtO1xuICBjb25zdCBpc28gPSBgJHtZfS0ke01vfS0ke0R9VCR7SH06JHtNaX06JHtTfSR7TXN9WmA7XG4gIGNvbnN0IGQgPSBuZXcgRGF0ZShpc28pO1xuICByZXR1cm4gaXNOYU4oZC5nZXRUaW1lKCkpID8gbnVsbCA6IGQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1pvbmVkKGRhdGU6IERhdGUsIHR6ID0gQlJBWklMX1RaKTogRGF0ZSB7XG4gIC8vIENyaWEgXCJlcXVpdmFsZW50ZVwiIG5vIGZ1c29cbiAgY29uc3QgaW52ID0gbmV3IERhdGUoZGF0ZS50b0xvY2FsZVN0cmluZygnZW4tVVMnLCB7IHRpbWVab25lOiB0eiB9KSk7XG4gIGNvbnN0IGRpZmYgPSBkYXRlLmdldFRpbWUoKSAtIGludi5nZXRUaW1lKCk7XG4gIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSAtIGRpZmYpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGF0ZVRpbWUoXG4gIGRhdGVMaWtlPzogc3RyaW5nIHwgRGF0ZSB8IG51bGwsXG4gIG9wdHM/OiBJbnRsLkRhdGVUaW1lRm9ybWF0T3B0aW9ucyxcbiAgdHogPSBCUkFaSUxfVFpcbik6IHN0cmluZyB7XG4gIGlmICghZGF0ZUxpa2UpIHJldHVybiAnLS0nO1xuICBcbiAgY29uc3QgZCA9IHR5cGVvZiBkYXRlTGlrZSA9PT0gJ3N0cmluZycgPyBwYXJzZUNsYXNoVGltZShkYXRlTGlrZSkgOiBuZXcgRGF0ZShkYXRlTGlrZSk7XG4gIGlmICghZCB8fCBpc05hTihkLmdldFRpbWUoKSkpIHJldHVybiAnLS0nO1xuICBcbiAgY29uc3QgeiA9IHRvWm9uZWQoZCwgdHopO1xuICBcbiAgLy8gQ2hlY2sgaWYgb3B0cyBjb250YWlucyBpbmRpdmlkdWFsIGRhdGUvdGltZSBjb21wb25lbnRzXG4gIGNvbnN0IGhhc0luZGl2aWR1YWxDb21wb25lbnRzID0gb3B0cyAmJiAoXG4gICAgJ3llYXInIGluIG9wdHMgfHwgJ21vbnRoJyBpbiBvcHRzIHx8ICdkYXknIGluIG9wdHMgfHxcbiAgICAnaG91cicgaW4gb3B0cyB8fCAnbWludXRlJyBpbiBvcHRzIHx8ICdzZWNvbmQnIGluIG9wdHMgfHxcbiAgICAnd2Vla2RheScgaW4gb3B0cyB8fCAnZXJhJyBpbiBvcHRzIHx8ICd0aW1lWm9uZU5hbWUnIGluIG9wdHNcbiAgKTtcbiAgXG4gIC8vIENoZWNrIGlmIG9wdHMgY29udGFpbnMgYW55IHZhbGlkIGZvcm1hdHRpbmcgb3B0aW9uc1xuICBjb25zdCBoYXNWYWxpZE9wdGlvbnMgPSBvcHRzICYmIChcbiAgICBoYXNJbmRpdmlkdWFsQ29tcG9uZW50cyB8fFxuICAgICdkYXRlU3R5bGUnIGluIG9wdHMgfHwgJ3RpbWVTdHlsZScgaW4gb3B0cyB8fFxuICAgICdsb2NhbGVNYXRjaGVyJyBpbiBvcHRzIHx8ICdmb3JtYXRNYXRjaGVyJyBpbiBvcHRzXG4gICk7XG4gIFxuICBjb25zdCBmb3JtYXRPcHRpb25zOiBJbnRsLkRhdGVUaW1lRm9ybWF0T3B0aW9ucyA9IHtcbiAgICB0aW1lWm9uZTogdHosXG4gICAgLi4ub3B0cyxcbiAgfTtcbiAgXG4gIC8vIE9ubHkgYWRkIGRhdGVTdHlsZS90aW1lU3R5bGUgaWYgbm8gaW5kaXZpZHVhbCBjb21wb25lbnRzIGFyZSBzcGVjaWZpZWQgYW5kIG5vIHZhbGlkIG9wdGlvbnMgZXhpc3RcbiAgaWYgKCFoYXNJbmRpdmlkdWFsQ29tcG9uZW50cyAmJiAhaGFzVmFsaWRPcHRpb25zKSB7XG4gICAgZm9ybWF0T3B0aW9ucy5kYXRlU3R5bGUgPSAnc2hvcnQnO1xuICAgIGZvcm1hdE9wdGlvbnMudGltZVN0eWxlID0gJ3Nob3J0JztcbiAgfVxuICBcbiAgcmV0dXJuIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KCdwdC1CUicsIGZvcm1hdE9wdGlvbnMpLmZvcm1hdCh6KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERhdGVPbmx5KFxuICBkYXRlTGlrZT86IHN0cmluZyB8IERhdGUgfCBudWxsLFxuICB0eiA9IEJSQVpJTF9UWlxuKTogc3RyaW5nIHtcbiAgcmV0dXJuIGZvcm1hdERhdGVUaW1lKGRhdGVMaWtlLCB7IGRhdGVTdHlsZTogJ21lZGl1bScsIHRpbWVTdHlsZTogdW5kZWZpbmVkIH0sIHR6KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFRpbWVPbmx5KFxuICBkYXRlTGlrZT86IHN0cmluZyB8IERhdGUgfCBudWxsLFxuICB0eiA9IEJSQVpJTF9UWlxuKTogc3RyaW5nIHtcbiAgcmV0dXJuIGZvcm1hdERhdGVUaW1lKGRhdGVMaWtlLCB7IGRhdGVTdHlsZTogdW5kZWZpbmVkLCB0aW1lU3R5bGU6ICdzaG9ydCcgfSwgdHopO1xufVxuXG4vLyBGdW7Dp8OjbyBleHRyYSBwYXJhIG1vc3RyYXIgXCJow6EgWCB0ZW1wb1wiXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0QWdvKGRhdGVMaWtlPzogc3RyaW5nIHwgRGF0ZSB8IG51bGwpOiBzdHJpbmcge1xuICBjb25zdCBkID0gdHlwZW9mIGRhdGVMaWtlID09PSAnc3RyaW5nJyA/IHBhcnNlQ2xhc2hUaW1lKGRhdGVMaWtlKSA6IG5ldyBEYXRlKGRhdGVMaWtlISk7XG4gIGlmICghZCB8fCBpc05hTihkLmdldFRpbWUoKSkpIHJldHVybiAnLS0nO1xuICBcbiAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSBkLmdldFRpbWUoKTtcbiAgY29uc3QgbWlucyA9IE1hdGguZmxvb3IoZGlmZiAvIDYwMDAwKTtcbiAgXG4gIGlmIChtaW5zIDwgMSkgcmV0dXJuICdhZ29yYSc7XG4gIGlmIChtaW5zIDwgNjApIHJldHVybiBgaMOhICR7bWluc30gbWluYDtcbiAgXG4gIGNvbnN0IGhycyA9IE1hdGguZmxvb3IobWlucyAvIDYwKTtcbiAgaWYgKGhycyA8IDI0KSByZXR1cm4gYGjDoSAke2hyc30gaGA7XG4gIFxuICBjb25zdCBkYXlzID0gTWF0aC5mbG9vcihocnMgLyAyNCk7XG4gIHJldHVybiBgaMOhICR7ZGF5c30gZGA7XG59XG5cbi8vIEZ1bsOnw6NvIHBhcmEgY2FsY3VsYXIgZHVyYcOnw6NvIGVudHJlIGR1YXMgZGF0YXNcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVEdXJhdGlvbihcbiAgc3RhcnREYXRlPzogc3RyaW5nIHwgRGF0ZSB8IG51bGwsXG4gIGVuZERhdGU/OiBzdHJpbmcgfCBEYXRlIHwgbnVsbFxuKTogc3RyaW5nIHtcbiAgY29uc3Qgc3RhcnQgPSB0eXBlb2Ygc3RhcnREYXRlID09PSAnc3RyaW5nJyA/IHBhcnNlQ2xhc2hUaW1lKHN0YXJ0RGF0ZSkgOiBuZXcgRGF0ZShzdGFydERhdGUhKTtcbiAgY29uc3QgZW5kID0gdHlwZW9mIGVuZERhdGUgPT09ICdzdHJpbmcnID8gcGFyc2VDbGFzaFRpbWUoZW5kRGF0ZSkgOiBuZXcgRGF0ZShlbmREYXRlISk7XG4gIFxuICBpZiAoIXN0YXJ0IHx8ICFlbmQgfHwgaXNOYU4oc3RhcnQuZ2V0VGltZSgpKSB8fCBpc05hTihlbmQuZ2V0VGltZSgpKSkgcmV0dXJuICctLSc7XG4gIFxuICBjb25zdCBkaWZmID0gZW5kLmdldFRpbWUoKSAtIHN0YXJ0LmdldFRpbWUoKTtcbiAgY29uc3QgZGF5cyA9IE1hdGguZmxvb3IoZGlmZiAvICgxMDAwICogNjAgKiA2MCAqIDI0KSk7XG4gIGNvbnN0IGhvdXJzID0gTWF0aC5mbG9vcigoZGlmZiAlICgxMDAwICogNjAgKiA2MCAqIDI0KSkgLyAoMTAwMCAqIDYwICogNjApKTtcbiAgY29uc3QgbWludXRlcyA9IE1hdGguZmxvb3IoKGRpZmYgJSAoMTAwMCAqIDYwICogNjApKSAvICgxMDAwICogNjApKTtcbiAgXG4gIGlmIChkYXlzID4gMCkgcmV0dXJuIGAke2RheXN9ZCAke2hvdXJzfWhgO1xuICBpZiAoaG91cnMgPiAwKSByZXR1cm4gYCR7aG91cnN9aCAke21pbnV0ZXN9bWA7XG4gIHJldHVybiBgJHttaW51dGVzfW1gO1xufVxuXG4vLyBGdW7Dp8OjbyBwYXJhIHZlcmlmaWNhciBzZSB1bWEgZGF0YSDDqSBkZSBob2plXG5leHBvcnQgZnVuY3Rpb24gaXNUb2RheShkYXRlTGlrZT86IHN0cmluZyB8IERhdGUgfCBudWxsLCB0eiA9IEJSQVpJTF9UWik6IGJvb2xlYW4ge1xuICBjb25zdCBkID0gdHlwZW9mIGRhdGVMaWtlID09PSAnc3RyaW5nJyA/IHBhcnNlQ2xhc2hUaW1lKGRhdGVMaWtlKSA6IG5ldyBEYXRlKGRhdGVMaWtlISk7XG4gIGlmICghZCB8fCBpc05hTihkLmdldFRpbWUoKSkpIHJldHVybiBmYWxzZTtcbiAgXG4gIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgY29uc3QgdGFyZ2V0ID0gdG9ab25lZChkLCB0eik7XG4gIFxuICByZXR1cm4gKFxuICAgIHRvZGF5LmdldEZ1bGxZZWFyKCkgPT09IHRhcmdldC5nZXRGdWxsWWVhcigpICYmXG4gICAgdG9kYXkuZ2V0TW9udGgoKSA9PT0gdGFyZ2V0LmdldE1vbnRoKCkgJiZcbiAgICB0b2RheS5nZXREYXRlKCkgPT09IHRhcmdldC5nZXREYXRlKClcbiAgKTtcbn1cblxuLy8gRnVuw6fDo28gcGFyYSBvcmRlbmFyIGFycmF5IHBvciBkYXRhIChtYWlzIHJlY2VudGUgcHJpbWVpcm8pXG5leHBvcnQgZnVuY3Rpb24gc29ydEJ5RGF0ZTxUIGV4dGVuZHMgeyBiYXR0bGVUaW1lPzogc3RyaW5nIH0+KFxuICBpdGVtczogVFtdLFxuICBkYXRlRmllbGQ6IGtleW9mIFQgPSAnYmF0dGxlVGltZScgYXMga2V5b2YgVCxcbiAgYXNjZW5kaW5nID0gZmFsc2Vcbik6IFRbXSB7XG4gIHJldHVybiBpdGVtc1xuICAgIC5tYXAoaXRlbSA9PiAoe1xuICAgICAgLi4uaXRlbSxcbiAgICAgIF9wYXJzZWREYXRlOiBwYXJzZUNsYXNoVGltZShpdGVtW2RhdGVGaWVsZF0gYXMgc3RyaW5nKVxuICAgIH0pKVxuICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLl9wYXJzZWREYXRlKVxuICAgIC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBjb25zdCBkYXRlQSA9IGEuX3BhcnNlZERhdGUhLmdldFRpbWUoKTtcbiAgICAgIGNvbnN0IGRhdGVCID0gYi5fcGFyc2VkRGF0ZSEuZ2V0VGltZSgpO1xuICAgICAgcmV0dXJuIGFzY2VuZGluZyA/IGRhdGVBIC0gZGF0ZUIgOiBkYXRlQiAtIGRhdGVBO1xuICAgIH0pXG4gICAgLm1hcCgoeyBfcGFyc2VkRGF0ZSwgLi4uaXRlbSB9KSA9PiBpdGVtKTtcbn1cblxuLyoqIEFsaWFzIGNvbXBhdMOtdmVsIGNvbSBvIHF1ZSBzZXUgY8OzZGlnbyBlc3BlcmF2YSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJyYXppbFRpbWUoKTogRGF0ZSB7XG4gIHJldHVybiB0b1pvbmVkKG5ldyBEYXRlKCksIEJSQVpJTF9UWik7XG59Il0sIm5hbWVzIjpbIkJSQVpJTF9UWiIsInBhcnNlQ2xhc2hUaW1lIiwiaW5wdXQiLCJ0ZXN0IiwiZCIsIkRhdGUiLCJpc05hTiIsImdldFRpbWUiLCJtIiwibWF0Y2giLCJZIiwiTW8iLCJEIiwiSCIsIk1pIiwiUyIsIk1zIiwiaXNvIiwidG9ab25lZCIsImRhdGUiLCJ0eiIsImludiIsInRvTG9jYWxlU3RyaW5nIiwidGltZVpvbmUiLCJkaWZmIiwiZm9ybWF0RGF0ZVRpbWUiLCJkYXRlTGlrZSIsIm9wdHMiLCJ6IiwiaGFzSW5kaXZpZHVhbENvbXBvbmVudHMiLCJoYXNWYWxpZE9wdGlvbnMiLCJmb3JtYXRPcHRpb25zIiwiZGF0ZVN0eWxlIiwidGltZVN0eWxlIiwiSW50bCIsIkRhdGVUaW1lRm9ybWF0IiwiZm9ybWF0IiwiZm9ybWF0RGF0ZU9ubHkiLCJ1bmRlZmluZWQiLCJmb3JtYXRUaW1lT25seSIsImZvcm1hdEFnbyIsIm5vdyIsIm1pbnMiLCJNYXRoIiwiZmxvb3IiLCJocnMiLCJkYXlzIiwiY2FsY3VsYXRlRHVyYXRpb24iLCJzdGFydERhdGUiLCJlbmREYXRlIiwic3RhcnQiLCJlbmQiLCJob3VycyIsIm1pbnV0ZXMiLCJpc1RvZGF5IiwidG9kYXkiLCJ0YXJnZXQiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsInNvcnRCeURhdGUiLCJpdGVtcyIsImRhdGVGaWVsZCIsImFzY2VuZGluZyIsIm1hcCIsIml0ZW0iLCJfcGFyc2VkRGF0ZSIsImZpbHRlciIsInNvcnQiLCJhIiwiYiIsImRhdGVBIiwiZGF0ZUIiLCJicmF6aWxUaW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/time.ts\n"));

/***/ })

});