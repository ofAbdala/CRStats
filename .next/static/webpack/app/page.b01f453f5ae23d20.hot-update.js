"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/time.ts":
/*!*********************!*\
  !*** ./lib/time.ts ***!
  \*********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BRAZIL_TZ: function() { return /* binding */ BRAZIL_TZ; },\n/* harmony export */   brazilTime: function() { return /* binding */ brazilTime; },\n/* harmony export */   calculateDuration: function() { return /* binding */ calculateDuration; },\n/* harmony export */   formatAgo: function() { return /* binding */ formatAgo; },\n/* harmony export */   formatDateOnly: function() { return /* binding */ formatDateOnly; },\n/* harmony export */   formatDateTime: function() { return /* binding */ formatDateTime; },\n/* harmony export */   formatTimeOnly: function() { return /* binding */ formatTimeOnly; },\n/* harmony export */   isToday: function() { return /* binding */ isToday; },\n/* harmony export */   parseClashTime: function() { return /* binding */ parseClashTime; },\n/* harmony export */   sortByDate: function() { return /* binding */ sortByDate; },\n/* harmony export */   toZoned: function() { return /* binding */ toZoned; }\n/* harmony export */ });\n// lib/time.ts\nconst BRAZIL_TZ = \"America/Sao_Paulo\";\n// Converte \"20250826T032310.000Z\" -> \"2025-08-26T03:23:10.000Z\" e cria Date\nfunction parseClashTime(input) {\n    if (!input || typeof input !== \"string\") return null;\n    // Já é ISO?\n    if (/^\\d{4}-\\d{2}-\\d{2}T/.test(input)) {\n        const d = new Date(input);\n        return isNaN(d.getTime()) ? null : d;\n    }\n    // Formato Clash: YYYYMMDDTHHMMSS(.mmm)?Z\n    const m = input.match(/^(\\d{4})(\\d{2})(\\d{2})T(\\d{2})(\\d{2})(\\d{2})(\\.\\d+)?Z$/);\n    if (!m) return null;\n    const [, Y, Mo, D, H, Mi, S, Ms = \".000\"] = m;\n    const iso = \"\".concat(Y, \"-\").concat(Mo, \"-\").concat(D, \"T\").concat(H, \":\").concat(Mi, \":\").concat(S).concat(Ms, \"Z\");\n    const d = new Date(iso);\n    return isNaN(d.getTime()) ? null : d;\n}\nfunction toZoned(date) {\n    let tz = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : BRAZIL_TZ;\n    // Cria \"equivalente\" no fuso\n    const inv = new Date(date.toLocaleString(\"en-US\", {\n        timeZone: tz\n    }));\n    const diff = date.getTime() - inv.getTime();\n    return new Date(date.getTime() - diff);\n}\nfunction formatDateTime(dateLike, opts) {\n    let tz = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : BRAZIL_TZ;\n    if (!dateLike) return \"--\";\n    const d = typeof dateLike === \"string\" ? parseClashTime(dateLike) : new Date(dateLike);\n    if (!d || isNaN(d.getTime())) return \"--\";\n    const z = toZoned(d, tz);\n    // Check if opts contains individual date/time components\n    const hasIndividualComponents = opts && (\"year\" in opts || \"month\" in opts || \"day\" in opts || \"hour\" in opts || \"minute\" in opts || \"second\" in opts || \"weekday\" in opts || \"era\" in opts || \"timeZoneName\" in opts);\n    const formatOptions = {\n        timeZone: tz,\n        ...opts\n    };\n    // Only add dateStyle/timeStyle if no individual components are specified\n    if (!hasIndividualComponents && !opts) {\n        formatOptions.dateStyle = \"short\";\n        formatOptions.timeStyle = \"short\";\n    }\n    return new Intl.DateTimeFormat(\"pt-BR\", formatOptions).format(z);\n}\nfunction formatDateOnly(dateLike) {\n    let tz = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : BRAZIL_TZ;\n    return formatDateTime(dateLike, {\n        dateStyle: \"medium\",\n        timeStyle: undefined\n    }, tz);\n}\nfunction formatTimeOnly(dateLike) {\n    let tz = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : BRAZIL_TZ;\n    return formatDateTime(dateLike, {\n        dateStyle: undefined,\n        timeStyle: \"short\"\n    }, tz);\n}\n// Função extra para mostrar \"há X tempo\"\nfunction formatAgo(dateLike) {\n    const d = typeof dateLike === \"string\" ? parseClashTime(dateLike) : new Date(dateLike);\n    if (!d || isNaN(d.getTime())) return \"--\";\n    const diff = Date.now() - d.getTime();\n    const mins = Math.floor(diff / 60000);\n    if (mins < 1) return \"agora\";\n    if (mins < 60) return \"h\\xe1 \".concat(mins, \" min\");\n    const hrs = Math.floor(mins / 60);\n    if (hrs < 24) return \"h\\xe1 \".concat(hrs, \" h\");\n    const days = Math.floor(hrs / 24);\n    return \"h\\xe1 \".concat(days, \" d\");\n}\n// Função para calcular duração entre duas datas\nfunction calculateDuration(startDate, endDate) {\n    const start = typeof startDate === \"string\" ? parseClashTime(startDate) : new Date(startDate);\n    const end = typeof endDate === \"string\" ? parseClashTime(endDate) : new Date(endDate);\n    if (!start || !end || isNaN(start.getTime()) || isNaN(end.getTime())) return \"--\";\n    const diff = end.getTime() - start.getTime();\n    const days = Math.floor(diff / (1000 * 60 * 60 * 24));\n    const hours = Math.floor(diff % (1000 * 60 * 60 * 24) / (1000 * 60 * 60));\n    const minutes = Math.floor(diff % (1000 * 60 * 60) / (1000 * 60));\n    if (days > 0) return \"\".concat(days, \"d \").concat(hours, \"h\");\n    if (hours > 0) return \"\".concat(hours, \"h \").concat(minutes, \"m\");\n    return \"\".concat(minutes, \"m\");\n}\n// Função para verificar se uma data é de hoje\nfunction isToday(dateLike) {\n    let tz = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : BRAZIL_TZ;\n    const d = typeof dateLike === \"string\" ? parseClashTime(dateLike) : new Date(dateLike);\n    if (!d || isNaN(d.getTime())) return false;\n    const today = new Date();\n    const target = toZoned(d, tz);\n    return today.getFullYear() === target.getFullYear() && today.getMonth() === target.getMonth() && today.getDate() === target.getDate();\n}\n// Função para ordenar array por data (mais recente primeiro)\nfunction sortByDate(items) {\n    let dateField = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"battleTime\", ascending = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    return items.map((item)=>({\n            ...item,\n            _parsedDate: parseClashTime(item[dateField])\n        })).filter((item)=>item._parsedDate).sort((a, b)=>{\n        const dateA = a._parsedDate.getTime();\n        const dateB = b._parsedDate.getTime();\n        return ascending ? dateA - dateB : dateB - dateA;\n    }).map((param)=>{\n        let { _parsedDate, ...item } = param;\n        return item;\n    });\n}\n/** Alias compatível com o que seu código esperava */ function brazilTime() {\n    return toZoned(new Date(), BRAZIL_TZ);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi90aW1lLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUEsY0FBYztBQUNQLE1BQU1BLFlBQVksb0JBQW9CO0FBRTdDLDRFQUE0RTtBQUNyRSxTQUFTQyxlQUFlQyxLQUFxQjtJQUNsRCxJQUFJLENBQUNBLFNBQVMsT0FBT0EsVUFBVSxVQUFVLE9BQU87SUFFaEQsWUFBWTtJQUNaLElBQUksc0JBQXNCQyxJQUFJLENBQUNELFFBQVE7UUFDckMsTUFBTUUsSUFBSSxJQUFJQyxLQUFLSDtRQUNuQixPQUFPSSxNQUFNRixFQUFFRyxPQUFPLE1BQU0sT0FBT0g7SUFDckM7SUFFQSx5Q0FBeUM7SUFDekMsTUFBTUksSUFBSU4sTUFBTU8sS0FBSyxDQUNuQjtJQUVGLElBQUksQ0FBQ0QsR0FBRyxPQUFPO0lBRWYsTUFBTSxHQUFHRSxHQUFHQyxJQUFJQyxHQUFHQyxHQUFHQyxJQUFJQyxHQUFHQyxLQUFLLE1BQU0sQ0FBQyxHQUFHUjtJQUM1QyxNQUFNUyxNQUFNLEdBQVFOLE9BQUxELEdBQUUsS0FBU0UsT0FBTkQsSUFBRyxLQUFRRSxPQUFMRCxHQUFFLEtBQVFFLE9BQUxELEdBQUUsS0FBU0UsT0FBTkQsSUFBRyxLQUFPRSxPQUFKRCxHQUFPLE9BQUhDLElBQUc7SUFDakQsTUFBTVosSUFBSSxJQUFJQyxLQUFLWTtJQUNuQixPQUFPWCxNQUFNRixFQUFFRyxPQUFPLE1BQU0sT0FBT0g7QUFDckM7QUFFTyxTQUFTYyxRQUFRQyxJQUFVO1FBQUVDLEtBQUFBLGlFQUFLcEI7SUFDdkMsNkJBQTZCO0lBQzdCLE1BQU1xQixNQUFNLElBQUloQixLQUFLYyxLQUFLRyxjQUFjLENBQUMsU0FBUztRQUFFQyxVQUFVSDtJQUFHO0lBQ2pFLE1BQU1JLE9BQU9MLEtBQUtaLE9BQU8sS0FBS2MsSUFBSWQsT0FBTztJQUN6QyxPQUFPLElBQUlGLEtBQUtjLEtBQUtaLE9BQU8sS0FBS2lCO0FBQ25DO0FBRU8sU0FBU0MsZUFDZEMsUUFBK0IsRUFDL0JDLElBQWlDO1FBQ2pDUCxLQUFBQSxpRUFBS3BCO0lBRUwsSUFBSSxDQUFDMEIsVUFBVSxPQUFPO0lBRXRCLE1BQU10QixJQUFJLE9BQU9zQixhQUFhLFdBQVd6QixlQUFleUIsWUFBWSxJQUFJckIsS0FBS3FCO0lBQzdFLElBQUksQ0FBQ3RCLEtBQUtFLE1BQU1GLEVBQUVHLE9BQU8sS0FBSyxPQUFPO0lBRXJDLE1BQU1xQixJQUFJVixRQUFRZCxHQUFHZ0I7SUFFckIseURBQXlEO0lBQ3pELE1BQU1TLDBCQUEwQkYsUUFDOUIsV0FBVUEsUUFBUSxXQUFXQSxRQUFRLFNBQVNBLFFBQzlDLFVBQVVBLFFBQVEsWUFBWUEsUUFBUSxZQUFZQSxRQUNsRCxhQUFhQSxRQUFRLFNBQVNBLFFBQVEsa0JBQWtCQSxJQUFHO0lBRzdELE1BQU1HLGdCQUE0QztRQUNoRFAsVUFBVUg7UUFDVixHQUFHTyxJQUFJO0lBQ1Q7SUFFQSx5RUFBeUU7SUFDekUsSUFBSSxDQUFDRSwyQkFBMkIsQ0FBQ0YsTUFBTTtRQUNyQ0csY0FBY0MsU0FBUyxHQUFHO1FBQzFCRCxjQUFjRSxTQUFTLEdBQUc7SUFDNUI7SUFFQSxPQUFPLElBQUlDLEtBQUtDLGNBQWMsQ0FBQyxTQUFTSixlQUFlSyxNQUFNLENBQUNQO0FBQ2hFO0FBRU8sU0FBU1EsZUFDZFYsUUFBK0I7UUFDL0JOLEtBQUFBLGlFQUFLcEI7SUFFTCxPQUFPeUIsZUFBZUMsVUFBVTtRQUFFSyxXQUFXO1FBQVVDLFdBQVdLO0lBQVUsR0FBR2pCO0FBQ2pGO0FBRU8sU0FBU2tCLGVBQ2RaLFFBQStCO1FBQy9CTixLQUFBQSxpRUFBS3BCO0lBRUwsT0FBT3lCLGVBQWVDLFVBQVU7UUFBRUssV0FBV007UUFBV0wsV0FBVztJQUFRLEdBQUdaO0FBQ2hGO0FBRUEseUNBQXlDO0FBQ2xDLFNBQVNtQixVQUFVYixRQUErQjtJQUN2RCxNQUFNdEIsSUFBSSxPQUFPc0IsYUFBYSxXQUFXekIsZUFBZXlCLFlBQVksSUFBSXJCLEtBQUtxQjtJQUM3RSxJQUFJLENBQUN0QixLQUFLRSxNQUFNRixFQUFFRyxPQUFPLEtBQUssT0FBTztJQUVyQyxNQUFNaUIsT0FBT25CLEtBQUttQyxHQUFHLEtBQUtwQyxFQUFFRyxPQUFPO0lBQ25DLE1BQU1rQyxPQUFPQyxLQUFLQyxLQUFLLENBQUNuQixPQUFPO0lBRS9CLElBQUlpQixPQUFPLEdBQUcsT0FBTztJQUNyQixJQUFJQSxPQUFPLElBQUksT0FBTyxTQUFXLE9BQUxBLE1BQUs7SUFFakMsTUFBTUcsTUFBTUYsS0FBS0MsS0FBSyxDQUFDRixPQUFPO0lBQzlCLElBQUlHLE1BQU0sSUFBSSxPQUFPLFNBQVUsT0FBSkEsS0FBSTtJQUUvQixNQUFNQyxPQUFPSCxLQUFLQyxLQUFLLENBQUNDLE1BQU07SUFDOUIsT0FBTyxTQUFXLE9BQUxDLE1BQUs7QUFDcEI7QUFFQSxnREFBZ0Q7QUFDekMsU0FBU0Msa0JBQ2RDLFNBQWdDLEVBQ2hDQyxPQUE4QjtJQUU5QixNQUFNQyxRQUFRLE9BQU9GLGNBQWMsV0FBVzlDLGVBQWU4QyxhQUFhLElBQUkxQyxLQUFLMEM7SUFDbkYsTUFBTUcsTUFBTSxPQUFPRixZQUFZLFdBQVcvQyxlQUFlK0MsV0FBVyxJQUFJM0MsS0FBSzJDO0lBRTdFLElBQUksQ0FBQ0MsU0FBUyxDQUFDQyxPQUFPNUMsTUFBTTJDLE1BQU0xQyxPQUFPLE9BQU9ELE1BQU00QyxJQUFJM0MsT0FBTyxLQUFLLE9BQU87SUFFN0UsTUFBTWlCLE9BQU8wQixJQUFJM0MsT0FBTyxLQUFLMEMsTUFBTTFDLE9BQU87SUFDMUMsTUFBTXNDLE9BQU9ILEtBQUtDLEtBQUssQ0FBQ25CLE9BQVEsUUFBTyxLQUFLLEtBQUssRUFBQztJQUNsRCxNQUFNMkIsUUFBUVQsS0FBS0MsS0FBSyxDQUFDLE9BQVMsUUFBTyxLQUFLLEtBQUssRUFBQyxJQUFPLFFBQU8sS0FBSyxFQUFDO0lBQ3hFLE1BQU1TLFVBQVVWLEtBQUtDLEtBQUssQ0FBQyxPQUFTLFFBQU8sS0FBSyxFQUFDLElBQU8sUUFBTyxFQUFDO0lBRWhFLElBQUlFLE9BQU8sR0FBRyxPQUFPLEdBQVlNLE9BQVROLE1BQUssTUFBVSxPQUFOTSxPQUFNO0lBQ3ZDLElBQUlBLFFBQVEsR0FBRyxPQUFPLEdBQWFDLE9BQVZELE9BQU0sTUFBWSxPQUFSQyxTQUFRO0lBQzNDLE9BQU8sR0FBVyxPQUFSQSxTQUFRO0FBQ3BCO0FBRUEsOENBQThDO0FBQ3ZDLFNBQVNDLFFBQVEzQixRQUErQjtRQUFFTixLQUFBQSxpRUFBS3BCO0lBQzVELE1BQU1JLElBQUksT0FBT3NCLGFBQWEsV0FBV3pCLGVBQWV5QixZQUFZLElBQUlyQixLQUFLcUI7SUFDN0UsSUFBSSxDQUFDdEIsS0FBS0UsTUFBTUYsRUFBRUcsT0FBTyxLQUFLLE9BQU87SUFFckMsTUFBTStDLFFBQVEsSUFBSWpEO0lBQ2xCLE1BQU1rRCxTQUFTckMsUUFBUWQsR0FBR2dCO0lBRTFCLE9BQ0VrQyxNQUFNRSxXQUFXLE9BQU9ELE9BQU9DLFdBQVcsTUFDMUNGLE1BQU1HLFFBQVEsT0FBT0YsT0FBT0UsUUFBUSxNQUNwQ0gsTUFBTUksT0FBTyxPQUFPSCxPQUFPRyxPQUFPO0FBRXRDO0FBRUEsNkRBQTZEO0FBQ3RELFNBQVNDLFdBQ2RDLEtBQVU7UUFDVkMsWUFBQUEsaUVBQXFCLGNBQ3JCQyxZQUFBQSxpRUFBWTtJQUVaLE9BQU9GLE1BQ0pHLEdBQUcsQ0FBQ0MsQ0FBQUEsT0FBUztZQUNaLEdBQUdBLElBQUk7WUFDUEMsYUFBYWhFLGVBQWUrRCxJQUFJLENBQUNILFVBQVU7UUFDN0MsSUFDQ0ssTUFBTSxDQUFDRixDQUFBQSxPQUFRQSxLQUFLQyxXQUFXLEVBQy9CRSxJQUFJLENBQUMsQ0FBQ0MsR0FBR0M7UUFDUixNQUFNQyxRQUFRRixFQUFFSCxXQUFXLENBQUUxRCxPQUFPO1FBQ3BDLE1BQU1nRSxRQUFRRixFQUFFSixXQUFXLENBQUUxRCxPQUFPO1FBQ3BDLE9BQU91RCxZQUFZUSxRQUFRQyxRQUFRQSxRQUFRRDtJQUM3QyxHQUNDUCxHQUFHLENBQUM7WUFBQyxFQUFFRSxXQUFXLEVBQUUsR0FBR0QsTUFBTTtlQUFLQTs7QUFDdkM7QUFFQSxtREFBbUQsR0FDNUMsU0FBU1E7SUFDZCxPQUFPdEQsUUFBUSxJQUFJYixRQUFRTDtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvdGltZS50cz82OGU4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGxpYi90aW1lLnRzXG5leHBvcnQgY29uc3QgQlJBWklMX1RaID0gJ0FtZXJpY2EvU2FvX1BhdWxvJztcblxuLy8gQ29udmVydGUgXCIyMDI1MDgyNlQwMzIzMTAuMDAwWlwiIC0+IFwiMjAyNS0wOC0yNlQwMzoyMzoxMC4wMDBaXCIgZSBjcmlhIERhdGVcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNsYXNoVGltZShpbnB1dD86IHN0cmluZyB8IG51bGwpOiBEYXRlIHwgbnVsbCB7XG4gIGlmICghaW5wdXQgfHwgdHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykgcmV0dXJuIG51bGw7XG4gIFxuICAvLyBKw6Egw6kgSVNPP1xuICBpZiAoL15cXGR7NH0tXFxkezJ9LVxcZHsyfVQvLnRlc3QoaW5wdXQpKSB7XG4gICAgY29uc3QgZCA9IG5ldyBEYXRlKGlucHV0KTtcbiAgICByZXR1cm4gaXNOYU4oZC5nZXRUaW1lKCkpID8gbnVsbCA6IGQ7XG4gIH1cbiAgXG4gIC8vIEZvcm1hdG8gQ2xhc2g6IFlZWVlNTUREVEhITU1TUygubW1tKT9aXG4gIGNvbnN0IG0gPSBpbnB1dC5tYXRjaChcbiAgICAvXihcXGR7NH0pKFxcZHsyfSkoXFxkezJ9KVQoXFxkezJ9KShcXGR7Mn0pKFxcZHsyfSkoXFwuXFxkKyk/WiQvXG4gICk7XG4gIGlmICghbSkgcmV0dXJuIG51bGw7XG4gIFxuICBjb25zdCBbLCBZLCBNbywgRCwgSCwgTWksIFMsIE1zID0gJy4wMDAnXSA9IG07XG4gIGNvbnN0IGlzbyA9IGAke1l9LSR7TW99LSR7RH1UJHtIfToke01pfToke1N9JHtNc31aYDtcbiAgY29uc3QgZCA9IG5ldyBEYXRlKGlzbyk7XG4gIHJldHVybiBpc05hTihkLmdldFRpbWUoKSkgPyBudWxsIDogZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvWm9uZWQoZGF0ZTogRGF0ZSwgdHogPSBCUkFaSUxfVFopOiBEYXRlIHtcbiAgLy8gQ3JpYSBcImVxdWl2YWxlbnRlXCIgbm8gZnVzb1xuICBjb25zdCBpbnYgPSBuZXcgRGF0ZShkYXRlLnRvTG9jYWxlU3RyaW5nKCdlbi1VUycsIHsgdGltZVpvbmU6IHR6IH0pKTtcbiAgY29uc3QgZGlmZiA9IGRhdGUuZ2V0VGltZSgpIC0gaW52LmdldFRpbWUoKTtcbiAgcmV0dXJuIG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpIC0gZGlmZik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREYXRlVGltZShcbiAgZGF0ZUxpa2U/OiBzdHJpbmcgfCBEYXRlIHwgbnVsbCxcbiAgb3B0cz86IEludGwuRGF0ZVRpbWVGb3JtYXRPcHRpb25zLFxuICB0eiA9IEJSQVpJTF9UWlxuKTogc3RyaW5nIHtcbiAgaWYgKCFkYXRlTGlrZSkgcmV0dXJuICctLSc7XG4gIFxuICBjb25zdCBkID0gdHlwZW9mIGRhdGVMaWtlID09PSAnc3RyaW5nJyA/IHBhcnNlQ2xhc2hUaW1lKGRhdGVMaWtlKSA6IG5ldyBEYXRlKGRhdGVMaWtlKTtcbiAgaWYgKCFkIHx8IGlzTmFOKGQuZ2V0VGltZSgpKSkgcmV0dXJuICctLSc7XG4gIFxuICBjb25zdCB6ID0gdG9ab25lZChkLCB0eik7XG4gIFxuICAvLyBDaGVjayBpZiBvcHRzIGNvbnRhaW5zIGluZGl2aWR1YWwgZGF0ZS90aW1lIGNvbXBvbmVudHNcbiAgY29uc3QgaGFzSW5kaXZpZHVhbENvbXBvbmVudHMgPSBvcHRzICYmIChcbiAgICAneWVhcicgaW4gb3B0cyB8fCAnbW9udGgnIGluIG9wdHMgfHwgJ2RheScgaW4gb3B0cyB8fFxuICAgICdob3VyJyBpbiBvcHRzIHx8ICdtaW51dGUnIGluIG9wdHMgfHwgJ3NlY29uZCcgaW4gb3B0cyB8fFxuICAgICd3ZWVrZGF5JyBpbiBvcHRzIHx8ICdlcmEnIGluIG9wdHMgfHwgJ3RpbWVab25lTmFtZScgaW4gb3B0c1xuICApO1xuICBcbiAgY29uc3QgZm9ybWF0T3B0aW9uczogSW50bC5EYXRlVGltZUZvcm1hdE9wdGlvbnMgPSB7XG4gICAgdGltZVpvbmU6IHR6LFxuICAgIC4uLm9wdHMsXG4gIH07XG4gIFxuICAvLyBPbmx5IGFkZCBkYXRlU3R5bGUvdGltZVN0eWxlIGlmIG5vIGluZGl2aWR1YWwgY29tcG9uZW50cyBhcmUgc3BlY2lmaWVkXG4gIGlmICghaGFzSW5kaXZpZHVhbENvbXBvbmVudHMgJiYgIW9wdHMpIHtcbiAgICBmb3JtYXRPcHRpb25zLmRhdGVTdHlsZSA9ICdzaG9ydCc7XG4gICAgZm9ybWF0T3B0aW9ucy50aW1lU3R5bGUgPSAnc2hvcnQnO1xuICB9XG4gIFxuICByZXR1cm4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoJ3B0LUJSJywgZm9ybWF0T3B0aW9ucykuZm9ybWF0KHopO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGF0ZU9ubHkoXG4gIGRhdGVMaWtlPzogc3RyaW5nIHwgRGF0ZSB8IG51bGwsXG4gIHR6ID0gQlJBWklMX1RaXG4pOiBzdHJpbmcge1xuICByZXR1cm4gZm9ybWF0RGF0ZVRpbWUoZGF0ZUxpa2UsIHsgZGF0ZVN0eWxlOiAnbWVkaXVtJywgdGltZVN0eWxlOiB1bmRlZmluZWQgfSwgdHopO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VGltZU9ubHkoXG4gIGRhdGVMaWtlPzogc3RyaW5nIHwgRGF0ZSB8IG51bGwsXG4gIHR6ID0gQlJBWklMX1RaXG4pOiBzdHJpbmcge1xuICByZXR1cm4gZm9ybWF0RGF0ZVRpbWUoZGF0ZUxpa2UsIHsgZGF0ZVN0eWxlOiB1bmRlZmluZWQsIHRpbWVTdHlsZTogJ3Nob3J0JyB9LCB0eik7XG59XG5cbi8vIEZ1bsOnw6NvIGV4dHJhIHBhcmEgbW9zdHJhciBcImjDoSBYIHRlbXBvXCJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRBZ28oZGF0ZUxpa2U/OiBzdHJpbmcgfCBEYXRlIHwgbnVsbCk6IHN0cmluZyB7XG4gIGNvbnN0IGQgPSB0eXBlb2YgZGF0ZUxpa2UgPT09ICdzdHJpbmcnID8gcGFyc2VDbGFzaFRpbWUoZGF0ZUxpa2UpIDogbmV3IERhdGUoZGF0ZUxpa2UhKTtcbiAgaWYgKCFkIHx8IGlzTmFOKGQuZ2V0VGltZSgpKSkgcmV0dXJuICctLSc7XG4gIFxuICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIGQuZ2V0VGltZSgpO1xuICBjb25zdCBtaW5zID0gTWF0aC5mbG9vcihkaWZmIC8gNjAwMDApO1xuICBcbiAgaWYgKG1pbnMgPCAxKSByZXR1cm4gJ2Fnb3JhJztcbiAgaWYgKG1pbnMgPCA2MCkgcmV0dXJuIGBow6EgJHttaW5zfSBtaW5gO1xuICBcbiAgY29uc3QgaHJzID0gTWF0aC5mbG9vcihtaW5zIC8gNjApO1xuICBpZiAoaHJzIDwgMjQpIHJldHVybiBgaMOhICR7aHJzfSBoYDtcbiAgXG4gIGNvbnN0IGRheXMgPSBNYXRoLmZsb29yKGhycyAvIDI0KTtcbiAgcmV0dXJuIGBow6EgJHtkYXlzfSBkYDtcbn1cblxuLy8gRnVuw6fDo28gcGFyYSBjYWxjdWxhciBkdXJhw6fDo28gZW50cmUgZHVhcyBkYXRhc1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUR1cmF0aW9uKFxuICBzdGFydERhdGU/OiBzdHJpbmcgfCBEYXRlIHwgbnVsbCxcbiAgZW5kRGF0ZT86IHN0cmluZyB8IERhdGUgfCBudWxsXG4pOiBzdHJpbmcge1xuICBjb25zdCBzdGFydCA9IHR5cGVvZiBzdGFydERhdGUgPT09ICdzdHJpbmcnID8gcGFyc2VDbGFzaFRpbWUoc3RhcnREYXRlKSA6IG5ldyBEYXRlKHN0YXJ0RGF0ZSEpO1xuICBjb25zdCBlbmQgPSB0eXBlb2YgZW5kRGF0ZSA9PT0gJ3N0cmluZycgPyBwYXJzZUNsYXNoVGltZShlbmREYXRlKSA6IG5ldyBEYXRlKGVuZERhdGUhKTtcbiAgXG4gIGlmICghc3RhcnQgfHwgIWVuZCB8fCBpc05hTihzdGFydC5nZXRUaW1lKCkpIHx8IGlzTmFOKGVuZC5nZXRUaW1lKCkpKSByZXR1cm4gJy0tJztcbiAgXG4gIGNvbnN0IGRpZmYgPSBlbmQuZ2V0VGltZSgpIC0gc3RhcnQuZ2V0VGltZSgpO1xuICBjb25zdCBkYXlzID0gTWF0aC5mbG9vcihkaWZmIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKTtcbiAgY29uc3QgaG91cnMgPSBNYXRoLmZsb29yKChkaWZmICUgKDEwMDAgKiA2MCAqIDYwICogMjQpKSAvICgxMDAwICogNjAgKiA2MCkpO1xuICBjb25zdCBtaW51dGVzID0gTWF0aC5mbG9vcigoZGlmZiAlICgxMDAwICogNjAgKiA2MCkpIC8gKDEwMDAgKiA2MCkpO1xuICBcbiAgaWYgKGRheXMgPiAwKSByZXR1cm4gYCR7ZGF5c31kICR7aG91cnN9aGA7XG4gIGlmIChob3VycyA+IDApIHJldHVybiBgJHtob3Vyc31oICR7bWludXRlc31tYDtcbiAgcmV0dXJuIGAke21pbnV0ZXN9bWA7XG59XG5cbi8vIEZ1bsOnw6NvIHBhcmEgdmVyaWZpY2FyIHNlIHVtYSBkYXRhIMOpIGRlIGhvamVcbmV4cG9ydCBmdW5jdGlvbiBpc1RvZGF5KGRhdGVMaWtlPzogc3RyaW5nIHwgRGF0ZSB8IG51bGwsIHR6ID0gQlJBWklMX1RaKTogYm9vbGVhbiB7XG4gIGNvbnN0IGQgPSB0eXBlb2YgZGF0ZUxpa2UgPT09ICdzdHJpbmcnID8gcGFyc2VDbGFzaFRpbWUoZGF0ZUxpa2UpIDogbmV3IERhdGUoZGF0ZUxpa2UhKTtcbiAgaWYgKCFkIHx8IGlzTmFOKGQuZ2V0VGltZSgpKSkgcmV0dXJuIGZhbHNlO1xuICBcbiAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICBjb25zdCB0YXJnZXQgPSB0b1pvbmVkKGQsIHR6KTtcbiAgXG4gIHJldHVybiAoXG4gICAgdG9kYXkuZ2V0RnVsbFllYXIoKSA9PT0gdGFyZ2V0LmdldEZ1bGxZZWFyKCkgJiZcbiAgICB0b2RheS5nZXRNb250aCgpID09PSB0YXJnZXQuZ2V0TW9udGgoKSAmJlxuICAgIHRvZGF5LmdldERhdGUoKSA9PT0gdGFyZ2V0LmdldERhdGUoKVxuICApO1xufVxuXG4vLyBGdW7Dp8OjbyBwYXJhIG9yZGVuYXIgYXJyYXkgcG9yIGRhdGEgKG1haXMgcmVjZW50ZSBwcmltZWlybylcbmV4cG9ydCBmdW5jdGlvbiBzb3J0QnlEYXRlPFQgZXh0ZW5kcyB7IGJhdHRsZVRpbWU/OiBzdHJpbmcgfT4oXG4gIGl0ZW1zOiBUW10sXG4gIGRhdGVGaWVsZDoga2V5b2YgVCA9ICdiYXR0bGVUaW1lJyBhcyBrZXlvZiBULFxuICBhc2NlbmRpbmcgPSBmYWxzZVxuKTogVFtdIHtcbiAgcmV0dXJuIGl0ZW1zXG4gICAgLm1hcChpdGVtID0+ICh7XG4gICAgICAuLi5pdGVtLFxuICAgICAgX3BhcnNlZERhdGU6IHBhcnNlQ2xhc2hUaW1lKGl0ZW1bZGF0ZUZpZWxkXSBhcyBzdHJpbmcpXG4gICAgfSkpXG4gICAgLmZpbHRlcihpdGVtID0+IGl0ZW0uX3BhcnNlZERhdGUpXG4gICAgLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IGRhdGVBID0gYS5fcGFyc2VkRGF0ZSEuZ2V0VGltZSgpO1xuICAgICAgY29uc3QgZGF0ZUIgPSBiLl9wYXJzZWREYXRlIS5nZXRUaW1lKCk7XG4gICAgICByZXR1cm4gYXNjZW5kaW5nID8gZGF0ZUEgLSBkYXRlQiA6IGRhdGVCIC0gZGF0ZUE7XG4gICAgfSlcbiAgICAubWFwKCh7IF9wYXJzZWREYXRlLCAuLi5pdGVtIH0pID0+IGl0ZW0pO1xufVxuXG4vKiogQWxpYXMgY29tcGF0w612ZWwgY29tIG8gcXVlIHNldSBjw7NkaWdvIGVzcGVyYXZhICovXG5leHBvcnQgZnVuY3Rpb24gYnJhemlsVGltZSgpOiBEYXRlIHtcbiAgcmV0dXJuIHRvWm9uZWQobmV3IERhdGUoKSwgQlJBWklMX1RaKTtcbn0iXSwibmFtZXMiOlsiQlJBWklMX1RaIiwicGFyc2VDbGFzaFRpbWUiLCJpbnB1dCIsInRlc3QiLCJkIiwiRGF0ZSIsImlzTmFOIiwiZ2V0VGltZSIsIm0iLCJtYXRjaCIsIlkiLCJNbyIsIkQiLCJIIiwiTWkiLCJTIiwiTXMiLCJpc28iLCJ0b1pvbmVkIiwiZGF0ZSIsInR6IiwiaW52IiwidG9Mb2NhbGVTdHJpbmciLCJ0aW1lWm9uZSIsImRpZmYiLCJmb3JtYXREYXRlVGltZSIsImRhdGVMaWtlIiwib3B0cyIsInoiLCJoYXNJbmRpdmlkdWFsQ29tcG9uZW50cyIsImZvcm1hdE9wdGlvbnMiLCJkYXRlU3R5bGUiLCJ0aW1lU3R5bGUiLCJJbnRsIiwiRGF0ZVRpbWVGb3JtYXQiLCJmb3JtYXQiLCJmb3JtYXREYXRlT25seSIsInVuZGVmaW5lZCIsImZvcm1hdFRpbWVPbmx5IiwiZm9ybWF0QWdvIiwibm93IiwibWlucyIsIk1hdGgiLCJmbG9vciIsImhycyIsImRheXMiLCJjYWxjdWxhdGVEdXJhdGlvbiIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJzdGFydCIsImVuZCIsImhvdXJzIiwibWludXRlcyIsImlzVG9kYXkiLCJ0b2RheSIsInRhcmdldCIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwic29ydEJ5RGF0ZSIsIml0ZW1zIiwiZGF0ZUZpZWxkIiwiYXNjZW5kaW5nIiwibWFwIiwiaXRlbSIsIl9wYXJzZWREYXRlIiwiZmlsdGVyIiwic29ydCIsImEiLCJiIiwiZGF0ZUEiLCJkYXRlQiIsImJyYXppbFRpbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/time.ts\n"));

/***/ })

});