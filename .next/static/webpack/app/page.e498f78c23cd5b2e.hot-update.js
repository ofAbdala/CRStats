"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/time.ts":
/*!*********************!*\
  !*** ./lib/time.ts ***!
  \*********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BRAZIL_TZ: function() { return /* binding */ BRAZIL_TZ; },\n/* harmony export */   brazilTime: function() { return /* binding */ brazilTime; },\n/* harmony export */   calculateDuration: function() { return /* binding */ calculateDuration; },\n/* harmony export */   formatAgo: function() { return /* binding */ formatAgo; },\n/* harmony export */   formatDateOnly: function() { return /* binding */ formatDateOnly; },\n/* harmony export */   formatDateTime: function() { return /* binding */ formatDateTime; },\n/* harmony export */   formatTimeOnly: function() { return /* binding */ formatTimeOnly; },\n/* harmony export */   isToday: function() { return /* binding */ isToday; },\n/* harmony export */   parseClashTime: function() { return /* binding */ parseClashTime; },\n/* harmony export */   sortByDate: function() { return /* binding */ sortByDate; },\n/* harmony export */   toZoned: function() { return /* binding */ toZoned; }\n/* harmony export */ });\n// lib/time.ts\nconst BRAZIL_TZ = \"America/Sao_Paulo\";\n// Converte \"20250826T032310.000Z\" -> \"2025-08-26T03:23:10.000Z\" e cria Date\nfunction parseClashTime(input) {\n    if (!input || typeof input !== \"string\") return null;\n    // Já é ISO?\n    if (/^\\d{4}-\\d{2}-\\d{2}T/.test(input)) {\n        const d = new Date(input);\n        return isNaN(d.getTime()) ? null : d;\n    }\n    // Formato Clash: YYYYMMDDTHHMMSS(.mmm)?Z\n    const m = input.match(/^(\\d{4})(\\d{2})(\\d{2})T(\\d{2})(\\d{2})(\\d{2})(\\.\\d+)?Z$/);\n    if (!m) return null;\n    const [, Y, Mo, D, H, Mi, S, Ms = \".000\"] = m;\n    const iso = \"\".concat(Y, \"-\").concat(Mo, \"-\").concat(D, \"T\").concat(H, \":\").concat(Mi, \":\").concat(S).concat(Ms, \"Z\");\n    const d = new Date(iso);\n    return isNaN(d.getTime()) ? null : d;\n}\nfunction toZoned(date) {\n    let tz = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : BRAZIL_TZ;\n    // Cria \"equivalente\" no fuso\n    const inv = new Date(date.toLocaleString(\"en-US\", {\n        timeZone: tz\n    }));\n    const diff = date.getTime() - inv.getTime();\n    return new Date(date.getTime() - diff);\n}\nfunction formatDateTime(dateLike, opts) {\n    let tz = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : BRAZIL_TZ;\n    if (!dateLike) return \"--\";\n    const d = typeof dateLike === \"string\" ? parseClashTime(dateLike) : new Date(dateLike);\n    if (!d || isNaN(d.getTime())) return \"--\";\n    const z = toZoned(d, tz);\n    // Check if opts contains individual date/time components\n    const hasIndividualComponents = opts && (\"year\" in opts || \"month\" in opts || \"day\" in opts || \"hour\" in opts || \"minute\" in opts || \"second\" in opts || \"weekday\" in opts || \"era\" in opts || \"timeZoneName\" in opts);\n    // Check if opts contains any valid formatting options\n    const hasValidOptions = opts && (hasIndividualComponents || \"dateStyle\" in opts || \"timeStyle\" in opts || \"localeMatcher\" in opts || \"formatMatcher\" in opts);\n    // Filter out undefined values from opts to prevent \"Invalid option\" errors\n    const cleanOpts = {};\n    if (opts) {\n        Object.entries(opts).forEach((param)=>{\n            let [key, value] = param;\n            if (value !== undefined) {\n                cleanOpts[key] = value;\n            }\n        });\n    }\n    const formatOptions = {\n        timeZone: tz,\n        ...cleanOpts\n    };\n    // Only add dateStyle/timeStyle if no individual components are specified and no valid options exist\n    if (!hasIndividualComponents && !hasValidOptions) {\n        formatOptions.dateStyle = \"short\";\n        formatOptions.timeStyle = \"short\";\n    }\n    return new Intl.DateTimeFormat(\"pt-BR\", formatOptions).format(z);\n}\nfunction formatDateOnly(dateLike) {\n    let tz = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : BRAZIL_TZ;\n    return formatDateTime(dateLike, {\n        dateStyle: \"medium\",\n        timeStyle: undefined\n    }, tz);\n}\nfunction formatTimeOnly(dateLike) {\n    let tz = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : BRAZIL_TZ;\n    return formatDateTime(dateLike, {\n        dateStyle: undefined,\n        timeStyle: \"short\"\n    }, tz);\n}\n// Função extra para mostrar \"há X tempo\"\nfunction formatAgo(dateLike) {\n    const d = typeof dateLike === \"string\" ? parseClashTime(dateLike) : new Date(dateLike);\n    if (!d || isNaN(d.getTime())) return \"--\";\n    const diff = Date.now() - d.getTime();\n    const mins = Math.floor(diff / 60000);\n    if (mins < 1) return \"agora\";\n    if (mins < 60) return \"h\\xe1 \".concat(mins, \" min\");\n    const hrs = Math.floor(mins / 60);\n    if (hrs < 24) return \"h\\xe1 \".concat(hrs, \" h\");\n    const days = Math.floor(hrs / 24);\n    return \"h\\xe1 \".concat(days, \" d\");\n}\n// Função para calcular duração entre duas datas\nfunction calculateDuration(startDate, endDate) {\n    const start = typeof startDate === \"string\" ? parseClashTime(startDate) : new Date(startDate);\n    const end = typeof endDate === \"string\" ? parseClashTime(endDate) : new Date(endDate);\n    if (!start || !end || isNaN(start.getTime()) || isNaN(end.getTime())) return \"--\";\n    const diff = end.getTime() - start.getTime();\n    const days = Math.floor(diff / (1000 * 60 * 60 * 24));\n    const hours = Math.floor(diff % (1000 * 60 * 60 * 24) / (1000 * 60 * 60));\n    const minutes = Math.floor(diff % (1000 * 60 * 60) / (1000 * 60));\n    if (days > 0) return \"\".concat(days, \"d \").concat(hours, \"h\");\n    if (hours > 0) return \"\".concat(hours, \"h \").concat(minutes, \"m\");\n    return \"\".concat(minutes, \"m\");\n}\n// Função para verificar se uma data é de hoje\nfunction isToday(dateLike) {\n    let tz = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : BRAZIL_TZ;\n    const d = typeof dateLike === \"string\" ? parseClashTime(dateLike) : new Date(dateLike);\n    if (!d || isNaN(d.getTime())) return false;\n    const today = new Date();\n    const target = toZoned(d, tz);\n    return today.getFullYear() === target.getFullYear() && today.getMonth() === target.getMonth() && today.getDate() === target.getDate();\n}\n// Função para ordenar array por data (mais recente primeiro)\nfunction sortByDate(items) {\n    let dateField = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"battleTime\", ascending = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    return items.map((item)=>({\n            ...item,\n            _parsedDate: parseClashTime(item[dateField])\n        })).filter((item)=>item._parsedDate).sort((a, b)=>{\n        const dateA = a._parsedDate.getTime();\n        const dateB = b._parsedDate.getTime();\n        return ascending ? dateA - dateB : dateB - dateA;\n    }).map((param)=>{\n        let { _parsedDate, ...item } = param;\n        return item;\n    });\n}\n/** Alias compatível com o que seu código esperava */ function brazilTime() {\n    return toZoned(new Date(), BRAZIL_TZ);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LGFBQWF2RSxlQUFlc0UsSUFBSSxDQUFDSCxVQUFVO1FBQzdDLElBQ0NLLE1BQU0sQ0FBQ0YsQ0FBQUEsT0FBUUEsS0FBS0MsV0FBVyxFQUMvQkUsSUFBSSxDQUFDLENBQUNDLEdBQUdDO1FBQ1IsTUFBTUMsUUFBUUYsRUFBRUgsV0FBVyxDQUFFakUsT0FBTztRQUNwQyxNQUFNdUUsUUFBUUYsRUFBRUosV0FBVyxDQUFFakUsT0FBTztRQUNwQyxPQUFPOEQsWUFBWVEsUUFBUUMsUUFBUUEsUUFBUUQ7SUFDN0MsR0FDQ1AsR0FBRyxDQUFDO1lBQUMsRUFBRUUsV0FBVyxFQUFFLEdBQUdELE1BQU07ZUFBS0E7O0FBQ3ZDO0FBRUEsbURBQW1ELEdBQzVDLFNBQVNRO0lBQ2QsT0FBTzdELFFBQVEsSUFBSWIsUUFBUUw7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3RpbWUudHM/NjhlOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBsaWIvdGltZS50c1xuZXhwb3J0IGNvbnN0IEJSQVpJTF9UWiA9ICdBbWVyaWNhL1Nhb19QYXVsbyc7XG5cbi8vIENvbnZlcnRlIFwiMjAyNTA4MjZUMDMyMzEwLjAwMFpcIiAtPiBcIjIwMjUtMDgtMjZUMDM6MjM6MTAuMDAwWlwiIGUgY3JpYSBEYXRlXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDbGFzaFRpbWUoaW5wdXQ/OiBzdHJpbmcgfCBudWxsKTogRGF0ZSB8IG51bGwge1xuICBpZiAoIWlucHV0IHx8IHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHJldHVybiBudWxsO1xuICBcbiAgLy8gSsOhIMOpIElTTz9cbiAgaWYgKC9eXFxkezR9LVxcZHsyfS1cXGR7Mn1ULy50ZXN0KGlucHV0KSkge1xuICAgIGNvbnN0IGQgPSBuZXcgRGF0ZShpbnB1dCk7XG4gICAgcmV0dXJuIGlzTmFOKGQuZ2V0VGltZSgpKSA/IG51bGwgOiBkO1xuICB9XG4gIFxuICAvLyBGb3JtYXRvIENsYXNoOiBZWVlZTU1ERFRISE1NU1MoLm1tbSk/WlxuICBjb25zdCBtID0gaW5wdXQubWF0Y2goXG4gICAgL14oXFxkezR9KShcXGR7Mn0pKFxcZHsyfSlUKFxcZHsyfSkoXFxkezJ9KShcXGR7Mn0pKFxcLlxcZCspP1okL1xuICApO1xuICBpZiAoIW0pIHJldHVybiBudWxsO1xuICBcbiAgY29uc3QgWywgWSwgTW8sIEQsIEgsIE1pLCBTLCBNcyA9ICcuMDAwJ10gPSBtO1xuICBjb25zdCBpc28gPSBgJHtZfS0ke01vfS0ke0R9VCR7SH06JHtNaX06JHtTfSR7TXN9WmA7XG4gIGNvbnN0IGQgPSBuZXcgRGF0ZShpc28pO1xuICByZXR1cm4gaXNOYU4oZC5nZXRUaW1lKCkpID8gbnVsbCA6IGQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1pvbmVkKGRhdGU6IERhdGUsIHR6ID0gQlJBWklMX1RaKTogRGF0ZSB7XG4gIC8vIENyaWEgXCJlcXVpdmFsZW50ZVwiIG5vIGZ1c29cbiAgY29uc3QgaW52ID0gbmV3IERhdGUoZGF0ZS50b0xvY2FsZVN0cmluZygnZW4tVVMnLCB7IHRpbWVab25lOiB0eiB9KSk7XG4gIGNvbnN0IGRpZmYgPSBkYXRlLmdldFRpbWUoKSAtIGludi5nZXRUaW1lKCk7XG4gIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSAtIGRpZmYpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGF0ZVRpbWUoXG4gIGRhdGVMaWtlPzogc3RyaW5nIHwgRGF0ZSB8IG51bGwsXG4gIG9wdHM/OiBJbnRsLkRhdGVUaW1lRm9ybWF0T3B0aW9ucyxcbiAgdHogPSBCUkFaSUxfVFpcbik6IHN0cmluZyB7XG4gIGlmICghZGF0ZUxpa2UpIHJldHVybiAnLS0nO1xuICBcbiAgY29uc3QgZCA9IHR5cGVvZiBkYXRlTGlrZSA9PT0gJ3N0cmluZycgPyBwYXJzZUNsYXNoVGltZShkYXRlTGlrZSkgOiBuZXcgRGF0ZShkYXRlTGlrZSk7XG4gIGlmICghZCB8fCBpc05hTihkLmdldFRpbWUoKSkpIHJldHVybiAnLS0nO1xuICBcbiAgY29uc3QgeiA9IHRvWm9uZWQoZCwgdHopO1xuICBcbiAgLy8gQ2hlY2sgaWYgb3B0cyBjb250YWlucyBpbmRpdmlkdWFsIGRhdGUvdGltZSBjb21wb25lbnRzXG4gIGNvbnN0IGhhc0luZGl2aWR1YWxDb21wb25lbnRzID0gb3B0cyAmJiAoXG4gICAgJ3llYXInIGluIG9wdHMgfHwgJ21vbnRoJyBpbiBvcHRzIHx8ICdkYXknIGluIG9wdHMgfHxcbiAgICAnaG91cicgaW4gb3B0cyB8fCAnbWludXRlJyBpbiBvcHRzIHx8ICdzZWNvbmQnIGluIG9wdHMgfHxcbiAgICAnd2Vla2RheScgaW4gb3B0cyB8fCAnZXJhJyBpbiBvcHRzIHx8ICd0aW1lWm9uZU5hbWUnIGluIG9wdHNcbiAgKTtcbiAgXG4gIC8vIENoZWNrIGlmIG9wdHMgY29udGFpbnMgYW55IHZhbGlkIGZvcm1hdHRpbmcgb3B0aW9uc1xuICBjb25zdCBoYXNWYWxpZE9wdGlvbnMgPSBvcHRzICYmIChcbiAgICBoYXNJbmRpdmlkdWFsQ29tcG9uZW50cyB8fFxuICAgICdkYXRlU3R5bGUnIGluIG9wdHMgfHwgJ3RpbWVTdHlsZScgaW4gb3B0cyB8fFxuICAgICdsb2NhbGVNYXRjaGVyJyBpbiBvcHRzIHx8ICdmb3JtYXRNYXRjaGVyJyBpbiBvcHRzXG4gICk7XG4gIFxuICAvLyBGaWx0ZXIgb3V0IHVuZGVmaW5lZCB2YWx1ZXMgZnJvbSBvcHRzIHRvIHByZXZlbnQgXCJJbnZhbGlkIG9wdGlvblwiIGVycm9yc1xuICBjb25zdCBjbGVhbk9wdHM6IEludGwuRGF0ZVRpbWVGb3JtYXRPcHRpb25zID0ge307XG4gIGlmIChvcHRzKSB7XG4gICAgT2JqZWN0LmVudHJpZXMob3B0cykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAoY2xlYW5PcHRzIGFzIGFueSlba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIFxuICBjb25zdCBmb3JtYXRPcHRpb25zOiBJbnRsLkRhdGVUaW1lRm9ybWF0T3B0aW9ucyA9IHtcbiAgICB0aW1lWm9uZTogdHosXG4gICAgLi4uY2xlYW5PcHRzLFxuICB9O1xuICBcbiAgLy8gT25seSBhZGQgZGF0ZVN0eWxlL3RpbWVTdHlsZSBpZiBubyBpbmRpdmlkdWFsIGNvbXBvbmVudHMgYXJlIHNwZWNpZmllZCBhbmQgbm8gdmFsaWQgb3B0aW9ucyBleGlzdFxuICBpZiAoIWhhc0luZGl2aWR1YWxDb21wb25lbnRzICYmICFoYXNWYWxpZE9wdGlvbnMpIHtcbiAgICBmb3JtYXRPcHRpb25zLmRhdGVTdHlsZSA9ICdzaG9ydCc7XG4gICAgZm9ybWF0T3B0aW9ucy50aW1lU3R5bGUgPSAnc2hvcnQnO1xuICB9XG4gIFxuICByZXR1cm4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoJ3B0LUJSJywgZm9ybWF0T3B0aW9ucykuZm9ybWF0KHopO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGF0ZU9ubHkoXG4gIGRhdGVMaWtlPzogc3RyaW5nIHwgRGF0ZSB8IG51bGwsXG4gIHR6ID0gQlJBWklMX1RaXG4pOiBzdHJpbmcge1xuICByZXR1cm4gZm9ybWF0RGF0ZVRpbWUoZGF0ZUxpa2UsIHsgZGF0ZVN0eWxlOiAnbWVkaXVtJywgdGltZVN0eWxlOiB1bmRlZmluZWQgfSwgdHopO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VGltZU9ubHkoXG4gIGRhdGVMaWtlPzogc3RyaW5nIHwgRGF0ZSB8IG51bGwsXG4gIHR6ID0gQlJBWklMX1RaXG4pOiBzdHJpbmcge1xuICByZXR1cm4gZm9ybWF0RGF0ZVRpbWUoZGF0ZUxpa2UsIHsgZGF0ZVN0eWxlOiB1bmRlZmluZWQsIHRpbWVTdHlsZTogJ3Nob3J0JyB9LCB0eik7XG59XG5cbi8vIEZ1bsOnw6NvIGV4dHJhIHBhcmEgbW9zdHJhciBcImjDoSBYIHRlbXBvXCJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRBZ28oZGF0ZUxpa2U/OiBzdHJpbmcgfCBEYXRlIHwgbnVsbCk6IHN0cmluZyB7XG4gIGNvbnN0IGQgPSB0eXBlb2YgZGF0ZUxpa2UgPT09ICdzdHJpbmcnID8gcGFyc2VDbGFzaFRpbWUoZGF0ZUxpa2UpIDogbmV3IERhdGUoZGF0ZUxpa2UhKTtcbiAgaWYgKCFkIHx8IGlzTmFOKGQuZ2V0VGltZSgpKSkgcmV0dXJuICctLSc7XG4gIFxuICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIGQuZ2V0VGltZSgpO1xuICBjb25zdCBtaW5zID0gTWF0aC5mbG9vcihkaWZmIC8gNjAwMDApO1xuICBcbiAgaWYgKG1pbnMgPCAxKSByZXR1cm4gJ2Fnb3JhJztcbiAgaWYgKG1pbnMgPCA2MCkgcmV0dXJuIGBow6EgJHttaW5zfSBtaW5gO1xuICBcbiAgY29uc3QgaHJzID0gTWF0aC5mbG9vcihtaW5zIC8gNjApO1xuICBpZiAoaHJzIDwgMjQpIHJldHVybiBgaMOhICR7aHJzfSBoYDtcbiAgXG4gIGNvbnN0IGRheXMgPSBNYXRoLmZsb29yKGhycyAvIDI0KTtcbiAgcmV0dXJuIGBow6EgJHtkYXlzfSBkYDtcbn1cblxuLy8gRnVuw6fDo28gcGFyYSBjYWxjdWxhciBkdXJhw6fDo28gZW50cmUgZHVhcyBkYXRhc1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUR1cmF0aW9uKFxuICBzdGFydERhdGU/OiBzdHJpbmcgfCBEYXRlIHwgbnVsbCxcbiAgZW5kRGF0ZT86IHN0cmluZyB8IERhdGUgfCBudWxsXG4pOiBzdHJpbmcge1xuICBjb25zdCBzdGFydCA9IHR5cGVvZiBzdGFydERhdGUgPT09ICdzdHJpbmcnID8gcGFyc2VDbGFzaFRpbWUoc3RhcnREYXRlKSA6IG5ldyBEYXRlKHN0YXJ0RGF0ZSEpO1xuICBjb25zdCBlbmQgPSB0eXBlb2YgZW5kRGF0ZSA9PT0gJ3N0cmluZycgPyBwYXJzZUNsYXNoVGltZShlbmREYXRlKSA6IG5ldyBEYXRlKGVuZERhdGUhKTtcbiAgXG4gIGlmICghc3RhcnQgfHwgIWVuZCB8fCBpc05hTihzdGFydC5nZXRUaW1lKCkpIHx8IGlzTmFOKGVuZC5nZXRUaW1lKCkpKSByZXR1cm4gJy0tJztcbiAgXG4gIGNvbnN0IGRpZmYgPSBlbmQuZ2V0VGltZSgpIC0gc3RhcnQuZ2V0VGltZSgpO1xuICBjb25zdCBkYXlzID0gTWF0aC5mbG9vcihkaWZmIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKTtcbiAgY29uc3QgaG91cnMgPSBNYXRoLmZsb29yKChkaWZmICUgKDEwMDAgKiA2MCAqIDYwICogMjQpKSAvICgxMDAwICogNjAgKiA2MCkpO1xuICBjb25zdCBtaW51dGVzID0gTWF0aC5mbG9vcigoZGlmZiAlICgxMDAwICogNjAgKiA2MCkpIC8gKDEwMDAgKiA2MCkpO1xuICBcbiAgaWYgKGRheXMgPiAwKSByZXR1cm4gYCR7ZGF5c31kICR7aG91cnN9aGA7XG4gIGlmIChob3VycyA+IDApIHJldHVybiBgJHtob3Vyc31oICR7bWludXRlc31tYDtcbiAgcmV0dXJuIGAke21pbnV0ZXN9bWA7XG59XG5cbi8vIEZ1bsOnw6NvIHBhcmEgdmVyaWZpY2FyIHNlIHVtYSBkYXRhIMOpIGRlIGhvamVcbmV4cG9ydCBmdW5jdGlvbiBpc1RvZGF5KGRhdGVMaWtlPzogc3RyaW5nIHwgRGF0ZSB8IG51bGwsIHR6ID0gQlJBWklMX1RaKTogYm9vbGVhbiB7XG4gIGNvbnN0IGQgPSB0eXBlb2YgZGF0ZUxpa2UgPT09ICdzdHJpbmcnID8gcGFyc2VDbGFzaFRpbWUoZGF0ZUxpa2UpIDogbmV3IERhdGUoZGF0ZUxpa2UhKTtcbiAgaWYgKCFkIHx8IGlzTmFOKGQuZ2V0VGltZSgpKSkgcmV0dXJuIGZhbHNlO1xuICBcbiAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICBjb25zdCB0YXJnZXQgPSB0b1pvbmVkKGQsIHR6KTtcbiAgXG4gIHJldHVybiAoXG4gICAgdG9kYXkuZ2V0RnVsbFllYXIoKSA9PT0gdGFyZ2V0LmdldEZ1bGxZZWFyKCkgJiZcbiAgICB0b2RheS5nZXRNb250aCgpID09PSB0YXJnZXQuZ2V0TW9udGgoKSAmJlxuICAgIHRvZGF5LmdldERhdGUoKSA9PT0gdGFyZ2V0LmdldERhdGUoKVxuICApO1xufVxuXG4vLyBGdW7Dp8OjbyBwYXJhIG9yZGVuYXIgYXJyYXkgcG9yIGRhdGEgKG1haXMgcmVjZW50ZSBwcmltZWlybylcbmV4cG9ydCBmdW5jdGlvbiBzb3J0QnlEYXRlPFQgZXh0ZW5kcyB7IGJhdHRsZVRpbWU/OiBzdHJpbmcgfT4oXG4gIGl0ZW1zOiBUW10sXG4gIGRhdGVGaWVsZDoga2V5b2YgVCA9ICdiYXR0bGVUaW1lJyBhcyBrZXlvZiBULFxuICBhc2NlbmRpbmcgPSBmYWxzZVxuKTogVFtdIHtcbiAgcmV0dXJuIGl0ZW1zXG4gICAgLm1hcChpdGVtID0+ICh7XG4gICAgICAuLi5pdGVtLFxuICAgICAgX3BhcnNlZERhdGU6IHBhcnNlQ2xhc2hUaW1lKGl0ZW1bZGF0ZUZpZWxkXSBhcyBzdHJpbmcpXG4gICAgfSkpXG4gICAgLmZpbHRlcihpdGVtID0+IGl0ZW0uX3BhcnNlZERhdGUpXG4gICAgLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IGRhdGVBID0gYS5fcGFyc2VkRGF0ZSEuZ2V0VGltZSgpO1xuICAgICAgY29uc3QgZGF0ZUIgPSBiLl9wYXJzZWREYXRlIS5nZXRUaW1lKCk7XG4gICAgICByZXR1cm4gYXNjZW5kaW5nID8gZGF0ZUEgLSBkYXRlQiA6IGRhdGVCIC0gZGF0ZUE7XG4gICAgfSlcbiAgICAubWFwKCh7IF9wYXJzZWREYXRlLCAuLi5pdGVtIH0pID0+IGl0ZW0pO1xufVxuXG4vKiogQWxpYXMgY29tcGF0w612ZWwgY29tIG8gcXVlIHNldSBjw7NkaWdvIGVzcGVyYXZhICovXG5leHBvcnQgZnVuY3Rpb24gYnJhemlsVGltZSgpOiBEYXRlIHtcbiAgcmV0dXJuIHRvWm9uZWQobmV3IERhdGUoKSwgQlJBWklMX1RaKTtcbn0iXSwibmFtZXMiOlsiQlJBWklMX1RaIiwicGFyc2VDbGFzaFRpbWUiLCJpbnB1dCIsInRlc3QiLCJkIiwiRGF0ZSIsImlzTmFOIiwiZ2V0VGltZSIsIm0iLCJtYXRjaCIsIlkiLCJNbyIsIkQiLCJIIiwiTWkiLCJTIiwiTXMiLCJpc28iLCJ0b1pvbmVkIiwiZGF0ZSIsInR6IiwiaW52IiwidG9Mb2NhbGVTdHJpbmciLCJ0aW1lWm9uZSIsImRpZmYiLCJmb3JtYXREYXRlVGltZSIsImRhdGVMaWtlIiwib3B0cyIsInoiLCJoYXNJbmRpdmlkdWFsQ29tcG9uZW50cyIsImhhc1ZhbGlkT3B0aW9ucyIsImNsZWFuT3B0cyIsIk9iamVjdCIsImVudHJpZXMiLCJmb3JFYWNoIiwia2V5IiwidmFsdWUiLCJ1bmRlZmluZWQiLCJmb3JtYXRPcHRpb25zIiwiZGF0ZVN0eWxlIiwidGltZVN0eWxlIiwiSW50bCIsIkRhdGVUaW1lRm9ybWF0IiwiZm9ybWF0IiwiZm9ybWF0RGF0ZU9ubHkiLCJmb3JtYXRUaW1lT25seSIsImZvcm1hdEFnbyIsIm5vdyIsIm1pbnMiLCJNYXRoIiwiZmxvb3IiLCJocnMiLCJkYXlzIiwiY2FsY3VsYXRlRHVyYXRpb24iLCJzdGFydERhdGUiLCJlbmREYXRlIiwic3RhcnQiLCJlbmQiLCJob3VycyIsIm1pbnV0ZXMiLCJpc1RvZGF5IiwidG9kYXkiLCJ0YXJnZXQiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsInNvcnRCeURhdGUiLCJpdGVtcyIsImRhdGVGaWVsZCIsImFzY2VuZGluZyIsIm1hcCIsIml0ZW0iLCJfcGFyc2VkRGF0ZSIsImZpbHRlciIsInNvcnQiLCJhIiwiYiIsImRhdGVBIiwiZGF0ZUIiLCJicmF6aWxUaW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/time.ts\n"));

/***/ })

});